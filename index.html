<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Attention Matrix Visualizer</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=DM+Sans:wght@400;500;600&display=swap');
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: 'DM Sans', sans-serif;
    background: #eaedf1; color: #2d2d30; min-height: 100vh;
  }

  /* Upload screen */
  #upload-screen {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    min-height: 100vh; gap: 24px; padding: 40px;
  }
  #upload-screen h1 { font-size: 28px; font-weight: 600; color: #1a1a1e; letter-spacing: -0.5px; }
  #upload-screen p.subtitle { color: #6b6b76; font-size: 14px; max-width: 480px; text-align: center; line-height: 1.6; }
  #drop-zone {
    width: 480px; max-width: 90vw; padding: 48px 32px;
    border: 2px dashed #b8bcc4; border-radius: 12px;
    text-align: center; cursor: pointer; transition: all 0.2s; background: #f5f6f8;
  }
  #drop-zone:hover, #drop-zone.dragover { border-color: #2a9d8f; background: #eaf5f3; }
  #drop-zone .icon { font-size: 36px; margin-bottom: 12px; }
  #drop-zone .main-text { font-size: 15px; color: #555; }
  #drop-zone .sub-text { font-size: 12px; color: #999; margin-top: 8px; }
  #file-input { display: none; }
  .status-msg { font-size: 13px; min-height: 20px; max-width: 600px; text-align: center; }
  .status-msg.error { color: #d32f2f; } .status-msg.loading { color: #2a9d8f; }
  .format-hint {
    background: #f5f6f8; border: 1px solid #d0d3d9; border-radius: 8px;
    padding: 16px 20px; max-width: 480px; width: 90vw;
  }
  .format-hint code {
    font-family: 'JetBrains Mono', monospace; font-size: 12px;
    background: #e2e4e9; padding: 2px 6px; border-radius: 4px; color: #1a7a6e;
  }
  .format-hint p { font-size: 13px; color: #6b6b76; line-height: 1.5; }

  /* Viz screen */
  #viz-screen { display: none; padding: 8px; }
  #top-bar {
    display: flex; align-items: center; gap: 16px;
    padding: 8px 12px; background: #f5f6f8; border: 1px solid #d0d3d9; border-radius: 8px;
    margin-bottom: 8px; flex-wrap: wrap;
  }
  .file-info {
    font-family: 'JetBrains Mono', monospace; font-size: 12px; color: #1a7a6e;
    background: #e4f2ef; padding: 4px 10px; border-radius: 4px;
  }
  .dims { font-size: 12px; color: #6b6b76; }
  #btn-reload {
    margin-left: auto; background: #e2e4e9; border: 1px solid #c5c8cf;
    color: #555; padding: 5px 14px; border-radius: 6px; cursor: pointer;
    font-size: 12px; font-family: 'DM Sans', sans-serif; transition: all 0.15s;
  }
  #btn-reload:hover { background: #d0d3d9; color: #1a1a1e; }

  /* Error banner */
  #viz-error {
    display: none; background: #fde8e8; border: 1px solid #f5c6c6;
    border-radius: 8px; padding: 12px 16px; margin-bottom: 8px;
    font-family: 'JetBrains Mono', monospace; font-size: 12px; color: #d32f2f;
    white-space: pre-wrap; word-break: break-all; max-height: 200px; overflow-y: auto;
  }

  /* Controls */
  #controls { position: relative; height: 82px; margin-bottom: 4px; overflow: visible; }
  #search-wrap { position: absolute; left: 5px; top: 0; width: 200px; z-index: 10; }
  #search-input {
    width: 100%; padding: 4px 26px 4px 8px;
    font-size: 11px; font-family: 'JetBrains Mono', monospace;
    border: 1px solid #c5c8cf; border-radius: 5px;
    background: #fff; color: #2d2d30; outline: none;
  }
  #search-input:focus { border-color: #2a9d8f; }
  #search-input::placeholder { color: #aaa; }
  #search-clear {
    position: absolute; right: 7px; top: 50%; transform: translateY(-50%);
    cursor: pointer; font-size: 15px; color: #999; display: none;
    user-select: none; line-height: 1;
  }
  #search-clear:hover { color: #333; }
  #dropdown {
    position: absolute; left: 0; right: 0; top: 100%;
    max-height: 200px; overflow-y: auto;
    background: #fff; border: 1px solid #c5c8cf;
    border-top: none; border-radius: 0 0 6px 6px;
    display: none; box-shadow: 0 6px 20px rgba(0,0,0,0.12); z-index: 20;
  }
  .dd-item {
    padding: 5px 10px; cursor: pointer; font-size: 11px;
    font-family: 'JetBrains Mono', monospace;
    border-bottom: 1px solid #eee; color: #2d2d30;
  }
  .dd-item:hover, .dd-item.kb-active { background: #e8f0fe; }
  .dd-item b { color: #000; }
  .dd-item .fullname { color: #888; font-size: 10px; margin-left: 4px; }

  .slider-box {
    position: absolute; font-size: 11px; color: #555;
    background: #f5f6f8; border: 1px solid #d0d3d9;
    border-radius: 5px; padding: 3px 8px;
  }
  .slider-box .lbl { font-weight: 600; min-width: 14px; }
  .slider-box .val {
    min-width: 20px; text-align: right; font-weight: 600; color: #1a1a1e;
    font-family: 'JetBrains Mono', monospace; font-size: 10px;
  }
  .slider-row { display: flex; align-items: center; gap: 4px; }
  .slider-box input[type=range] { flex: 1; height: 14px; cursor: pointer; accent-color: #2a9d8f; }
  .layer-title { font-weight: 600; text-align: center; margin-bottom: 2px; color: #1a1a1e; font-size: 11px; }

  #scroll-container {
    overflow: auto; background: #f0f1f4;
    border: 1px solid #d0d3d9; border-radius: 0 0 8px 8px;
    max-height: calc(100vh - 180px);
  }
  #content-sizer { position: relative; }
  #thresh-canvas { position: absolute; top: 0; left: 0; }
  #viz-svg { position: absolute; top: 0; left: 0; z-index: 1; }

  #scroll-container::-webkit-scrollbar { width: 8px; }
  #scroll-container::-webkit-scrollbar-track { background: #e2e4e9; }
  #scroll-container::-webkit-scrollbar-thumb { background: #b8bcc4; border-radius: 4px; }
  #scroll-container::-webkit-scrollbar-thumb:hover { background: #999; }
</style>
</head>
<body>

<div id="upload-screen">
  <h1>Attention Matrix Visualizer</h1>
  <p class="subtitle">Interactive exploration of multi-layer attention patterns in biochemical reaction networks.</p>
  <div id="drop-zone">
    <div class="icon">ðŸ“‚</div>
    <div class="main-text">Drop <code>.attnbin</code> file here or click to browse</div>
    <div class="sub-text">Supports fp32 and fp16 formats</div>
  </div>
  <input type="file" id="file-input" accept=".attnbin,.bin">
  <div id="upload-status" class="status-msg"></div>
  <div class="format-hint">
    <p>Export from Python with <code>export_attention.py</code>:</p>
    <p style="margin-top:6px;"><code>export_attention_data('model.attnbin', ids, names, tensors, bounds)</code></p>
  </div>
</div>

<div id="viz-screen">
  <div id="top-bar">
    <span class="file-info" id="file-name"></span>
    <span class="dims" id="dims-info"></span>
    <button id="btn-reload">Load another file</button>
  </div>
  <div id="viz-error"></div>
  <div id="controls"></div>
  <div id="scroll-container">
    <div id="content-sizer">
      <canvas id="thresh-canvas"></canvas>
      <svg id="viz-svg" xmlns="http://www.w3.org/2000/svg"></svg>
    </div>
  </div>
</div>

<script>
// ================================================================
//  WORKER (inline Blob)
// ================================================================
let workerUrl = null;
try {
  const workerCode = `
self.onmessage = function(e) {
  const {matrix, N, threshFrac, maxLines, layer} = e.data;
  let mn = Infinity, mx = -Infinity;
  for (let i = 0, len = N * N; i < len; i++) {
    const v = Math.abs(matrix[i]);
    if (v < mn) mn = v;
    if (v > mx) mx = v;
  }
  const thresh = mn + threshFrac * (mx - mn);
  const entries = [];
  for (let r = 0; r < N; r++) {
    const base = r * N;
    for (let c = 0; c < N; c++) {
      const v = Math.abs(matrix[base + c]);
      if (v >= thresh) entries.push((r << 16) | c | 0, v);
    }
  }
  const n = entries.length / 2;
  const idx = new Array(n);
  for (let i = 0; i < n; i++) idx[i] = i;
  idx.sort((a, b) => entries[b * 2 + 1] - entries[a * 2 + 1]);
  const limit = Math.min(n, maxLines);
  const range = mx - thresh;
  const result = new Float32Array(limit * 3);
  for (let i = 0; i < limit; i++) {
    const j = idx[i];
    const rc = entries[j * 2];
    const v = entries[j * 2 + 1];
    let alpha = 0.08;
    if (range > 0) alpha = 0.05 + ((v - thresh) / range) * 0.45;
    result[i * 3] = rc >> 16;
    result[i * 3 + 1] = rc & 0xFFFF;
    result[i * 3 + 2] = alpha;
  }
  self.postMessage({result, layer, thresh, count: limit}, [result.buffer]);
};
`;
  workerUrl = URL.createObjectURL(new Blob([workerCode], {type: 'application/javascript'}));
} catch (e) { /* fallback to main thread */ }

// ================================================================
//  CONSTANTS
// ================================================================
const PALETTE = [
  ['#2a9d8f','#1d7068','#3fc0b0'],['#c47a53','#8e5535','#dba07a'],
  ['#7b68ae','#554889','#9d8dcf'],['#c97b84','#9e545d','#e4a5ad'],
  ['#8a9a5b','#647040','#a8bb78'],['#6a7fdb','#4a5aab','#90a0ef'],
  ['#b07aa1','#875c7d','#cf9ec2'],['#c4a35a','#9a7d3a','#dfbf7a'],
  ['#56b6a6','#3d8f82','#78d4c5'],['#d4816b','#a85d4a','#eba591'],
  ['#6b9e8a','#4c7a67','#8ec2ac'],['#a0855b','#7a6340','#c0a57b'],
];
const NAME_X = 5, NAME_W = 200, GUIDE_GAP = 25;
const NODE_W = 22, NODE_H = 8, GAP = 1;
const COL_SP = 175, SL_W = 155, TOP_PAD = 50, BOT_PAD = 15, MAX_TL = 600;

// ================================================================
//  STATE
// ================================================================
let S = null, workers = [], threshCache = [], useWorkers = true;
let chain = [], hlRects = [], segments = [];
let pinnedIdx = -1, pinnedRect = null, activeRowIdx = -1;

// ================================================================
//  FILE HANDLING
// ================================================================
const dropZone = document.getElementById('drop-zone');
const fileInput = document.getElementById('file-input');
const statusEl = document.getElementById('upload-status');
const vizErrEl = document.getElementById('viz-error');

dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', e => {
  e.preventDefault(); dropZone.classList.remove('dragover');
  if (e.dataTransfer.files.length) loadFile(e.dataTransfer.files[0]);
});
fileInput.addEventListener('change', e => { if (e.target.files.length) loadFile(e.target.files[0]); });
document.getElementById('btn-reload').addEventListener('click', () => {
  document.getElementById('viz-screen').style.display = 'none';
  document.getElementById('upload-screen').style.display = 'flex';
  teardown();
});

async function loadFile(file) {
  statusEl.className = 'status-msg loading';
  statusEl.textContent = `Loading ${file.name} (${(file.size/1e6).toFixed(1)} MB)...`;
  try {
    const buf = await file.arrayBuffer();
    parseAndInit(buf, file.name);
  } catch (err) {
    statusEl.className = 'status-msg error';
    statusEl.textContent = 'Error: ' + err.message;
  }
}

function parseAndInit(buf, fileName) {
  const view = new DataView(buf);
  const headerLen = view.getUint32(0, true);
  if (headerLen > buf.byteLength - 4 || headerLen > 1e7)
    throw new Error('Invalid header length: ' + headerLen);

  const headerRaw = new Uint8Array(buf, 4, headerLen);
  let jsonEnd = headerLen;
  while (jsonEnd > 0 && headerRaw[jsonEnd - 1] === 0) jsonEnd--;
  const header = JSON.parse(new TextDecoder().decode(new Uint8Array(buf, 4, jsonEnd)));

  if (header.format !== 'attnbin_v1') throw new Error('Unknown format: ' + header.format);

  const {N, B, H, L} = header;
  const isFp16 = header.dtype === 'float16';
  const bpf = isFp16 ? 2 : 4;
  const dataStart = 4 + headerLen;
  const boundsSize = B * N * 4;
  const layerBytes = B * H * N * N * bpf;
  const sliceFloats = N * N;
  const sliceBytes = sliceFloats * bpf;
  const expectedTotal = dataStart + boundsSize + L * layerBytes;

  if (buf.byteLength < expectedTotal)
    throw new Error(`File too small: expected ${expectedTotal} bytes, got ${buf.byteLength}`);

  S = {
    buf, N, B, H, L, isFp16, bpf,
    ids: header.reaction_ids,
    fullNames: header.full_names || header.reaction_ids,
    dataStart, boundsSize, layerBytes, sliceBytes, sliceFloats, fileName,
  };

  const col0x = NAME_X + NAME_W + GUIDE_GAP;
  S.colX = []; for (let i = 0; i <= L; i++) S.colX.push(col0x + i * COL_SP);
  S.totalWidth = S.colX[L] + NODE_W + 30;
  S.yPos = []; for (let i = 0; i < N; i++) S.yPos.push(TOP_PAD + i * (NODE_H + GAP));
  S.svgHeight = TOP_PAD + N * (NODE_H + GAP) + BOT_PAD;
  S.bandX = NAME_X; S.bandW = S.colX[L] + NODE_W - NAME_X;

  statusEl.textContent = '';
  document.getElementById('upload-screen').style.display = 'none';
  document.getElementById('viz-screen').style.display = 'block';
  document.getElementById('file-name').textContent = fileName;
  document.getElementById('dims-info').textContent = `N=${N}  B=${B}  H=${H}  L=${L}  ${isFp16?'fp16':'fp32'}`;
  vizErrEl.style.display = 'none';

  try { buildViz(); }
  catch (err) { vizErrEl.style.display = 'block'; vizErrEl.textContent = err.message + '\n' + err.stack; }
}

// ================================================================
//  DATA ACCESS (alignment-safe)
// ================================================================
function getBoundsSlice(batch) {
  const off = S.dataStart + batch * S.N * 4;
  const dst = new Float32Array(S.N);
  new Uint8Array(dst.buffer).set(new Uint8Array(S.buf, off, S.N * 4));
  return dst;
}

function getAttentionSlice(layer, batch, head) {
  const off = S.dataStart + S.boundsSize + layer * S.layerBytes + (batch * S.H + head) * S.sliceBytes;
  if (S.isFp16) {
    const u16 = new Uint16Array(S.sliceFloats);
    new Uint8Array(u16.buffer).set(new Uint8Array(S.buf, off, S.sliceFloats * 2));
    const f32 = new Float32Array(S.sliceFloats);
    for (let i = 0; i < S.sliceFloats; i++) f32[i] = fp16to32(u16[i]);
    return f32;
  }
  const f32 = new Float32Array(S.sliceFloats);
  new Uint8Array(f32.buffer).set(new Uint8Array(S.buf, off, S.sliceFloats * 4));
  return f32;
}

function fp16to32(h) {
  const s = (h >> 15) & 1, e = (h >> 10) & 0x1F, m = h & 0x3FF;
  if (e === 0) return m === 0 ? (s ? -0 : 0) : (s ? -1 : 1) * (m / 1024) * Math.pow(2, -14);
  if (e === 31) return m ? NaN : (s ? -Infinity : Infinity);
  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + m / 1024);
}

// ================================================================
//  BUILD VIZ
// ================================================================
const svgNS = 'http://www.w3.org/2000/svg';
const svgEl = document.getElementById('viz-svg');
const canvas = document.getElementById('thresh-canvas');
const ctx = canvas.getContext('2d');
const scrollEl = document.getElementById('scroll-container');
const sizer = document.getElementById('content-sizer');

let svgG = {}, rowBand = null, redRects = [];
let curBatch = 0, curHeads = [], curThreshFracs = [];
let ttRect, ttText1, ttText2;

function teardown() {
  workers.forEach(w => w.terminate()); workers = [];
  chain = []; hlRects = []; segments = [];
  pinnedIdx = -1; pinnedRect = null; activeRowIdx = -1;
  svgEl.innerHTML = ''; redRects = [];
  canvas.width = 0; canvas.height = 0;
  document.getElementById('controls').innerHTML = '';
  vizErrEl.style.display = 'none';
  S = null; threshCache = [];
}

function buildViz() {
  const {N, B, H, L, colX, totalWidth, svgHeight, bandX, bandW, yPos, ids, fullNames} = S;

  sizer.style.width = totalWidth + 'px'; sizer.style.height = svgHeight + 'px';
  canvas.width = totalWidth; canvas.height = svgHeight;
  canvas.style.width = totalWidth + 'px'; canvas.style.height = svgHeight + 'px';
  svgEl.setAttribute('width', totalWidth); svgEl.setAttribute('height', svgHeight);
  svgEl.style.width = totalWidth + 'px'; svgEl.style.height = svgHeight + 'px';

  let css = '';
  for (let c = 0; c <= L; c++) {
    const [f, s, h] = PALETTE[c % PALETTE.length];
    css += `.ncol${c}{fill:${f};stroke:${s};stroke-width:0.3;cursor:pointer;}.ncol${c}:hover{fill:${h};}`;
  }
  css += `.hl{fill:none;stroke:#ff69b4;stroke-width:2;pointer-events:none;rx:2;ry:2;}`;
  css += `.conn{stroke:#ff69b4;pointer-events:none;}`;
  css += `.vl{pointer-events:none;font-size:9px;fill:#c0458a;font-weight:bold;font-family:'JetBrains Mono',monospace;}`;
  css += `.nbg{fill:#1a1a1a;rx:1;ry:1;}.nred{fill:#cc2222;rx:1;ry:1;pointer-events:none;}`;
  css += `.nbar{fill:transparent;stroke:none;cursor:pointer;rx:1;ry:1;}.nbar:hover{stroke:#ffcc00;stroke-width:1.2;}`;
  css += `.ntxt{fill:#fff;font-size:${Math.max(NODE_H-2,5)}px;font-family:'JetBrains Mono',monospace;pointer-events:none;}`;
  css += `.guide{stroke:#b8bcc4;stroke-width:0.5;stroke-dasharray:2,2;pointer-events:none;}`;
  css += `.rowband{fill:#aab0ba;opacity:0.3;pointer-events:none;}`;
  css += `.pinband{fill:#ffe066;opacity:0.38;pointer-events:none;}`;
  css += `.tt{pointer-events:none;}`;
  const styleEl = document.createElementNS(svgNS, 'style');
  styleEl.textContent = css; svgEl.appendChild(styleEl);

  svgG.pinBand = mg(); svgG.hoverBand = mg(); svgG.conn = mg(); svgG.nodes = mg();

  rowBand = mr(bandX, 0, bandW, NODE_H, 'rowband');
  rowBand.setAttribute('visibility', 'hidden');
  svgG.hoverBand.appendChild(rowBand);

  redRects = [];
  for (let i = 0; i < N; i++) {
    const y = yPos[i];
    svgG.nodes.appendChild(mr(NAME_X, y, NAME_W, NODE_H, 'nbg'));
    const red = mr(NAME_X, y, 0, NODE_H, 'nred');
    svgG.nodes.appendChild(red); redRects.push(red);
    const txt = document.createElementNS(svgNS, 'text');
    txt.setAttribute('x', NAME_X + 3); txt.setAttribute('y', y + NODE_H - 1.5);
    txt.classList.add('ntxt'); txt.textContent = ids[i]; svgG.nodes.appendChild(txt);
    const hit = mr(NAME_X, y, NAME_W, NODE_H, 'nbar');
    hit.dataset.nbar = i; svgG.nodes.appendChild(hit);
    const gl = document.createElementNS(svgNS, 'line');
    gl.setAttribute('x1', NAME_X + NAME_W); gl.setAttribute('y1', yc(i));
    gl.setAttribute('x2', colX[0]); gl.setAttribute('y2', yc(i));
    gl.classList.add('guide'); svgG.nodes.appendChild(gl);
  }
  for (let col = 0; col <= L; col++) {
    for (let i = 0; i < N; i++) {
      const r = mr(colX[col], yPos[i], NODE_W, NODE_H, 'ncol' + col);
      r.setAttribute('rx', 1); r.setAttribute('ry', 1);
      r.dataset.col = col; r.dataset.idx = i; svgG.nodes.appendChild(r);
    }
  }

  // Tooltip
  ttRect = mr(0,0,0,0,'tt');
  ttRect.setAttribute('rx',4); ttRect.setAttribute('ry',4);
  ttRect.setAttribute('fill','#fff'); ttRect.setAttribute('stroke','#c5c8cf');
  ttRect.setAttribute('stroke-width',0.8); ttRect.setAttribute('visibility','hidden');
  svgEl.appendChild(ttRect);
  ttText1 = document.createElementNS(svgNS,'text'); ttText1.classList.add('tt');
  ttText1.setAttribute('font-size','11'); ttText1.setAttribute('fill','#1a1a1e');
  ttText1.setAttribute('font-family',"'JetBrains Mono',monospace");
  ttText1.setAttribute('visibility','hidden'); svgEl.appendChild(ttText1);
  ttText2 = document.createElementNS(svgNS,'text'); ttText2.classList.add('tt');
  ttText2.setAttribute('font-size','10'); ttText2.setAttribute('fill','#6b6b76');
  ttText2.setAttribute('font-family',"'JetBrains Mono',monospace");
  ttText2.setAttribute('visibility','hidden'); svgEl.appendChild(ttText2);

  buildControls();

  threshCache = new Array(L).fill(null);
  if (workerUrl) {
    try {
      for (let l = 0; l < L; l++) {
        const w = new Worker(workerUrl);
        w.onmessage = onWorkerMsg;
        w.onerror = () => { useWorkers = false; };
        workers.push(w);
      }
      useWorkers = true;
    } catch (e) { useWorkers = false; }
  } else { useWorkers = false; }

  updateRedFills();
  requestAllThresh();

  svgEl.addEventListener('click', onSvgClick);
  svgEl.addEventListener('mousemove', onSvgMove);
  svgEl.addEventListener('mouseleave', () => { hideRowBand(); hideTT(); });
}

function mg() { const g = document.createElementNS(svgNS,'g'); svgEl.appendChild(g); return g; }
function mr(x,y,w,h,cls) {
  const r = document.createElementNS(svgNS,'rect');
  r.setAttribute('x',x);r.setAttribute('y',y);r.setAttribute('width',w);r.setAttribute('height',h);
  if(cls)r.classList.add(cls); return r;
}
function yc(i) { return S.yPos[i] + NODE_H / 2; }
function debounce(fn, ms) { let t; return function(...a) { clearTimeout(t); t = setTimeout(() => fn.apply(this, a), ms); }; }

// ================================================================
//  CONTROLS
// ================================================================
function buildControls() {
  const {N, B, H, L, colX, totalWidth} = S;
  const cDiv = document.getElementById('controls');
  cDiv.style.width = totalWidth + 'px'; cDiv.innerHTML = '';

  const sw = document.createElement('div'); sw.id = 'search-wrap';
  sw.innerHTML = `<div style="position:relative;">
    <input id="search-input" type="text" placeholder="Search reaction..." autocomplete="off">
    <span id="search-clear">&times;</span>
    <div id="dropdown"></div></div>`;
  cDiv.appendChild(sw);

  const bb = document.createElement('div'); bb.className = 'slider-box';
  bb.style.cssText = 'left:5px;top:26px;width:200px;';
  bb.innerHTML = `<div class="slider-row"><span class="lbl">Batch</span>
    <input type="range" id="sl-batch" min="0" max="${B-1}" value="0">
    <span class="val" id="val-batch">0</span></div>`;
  cDiv.appendChild(bb);

  curHeads = new Array(L).fill(0);
  curThreshFracs = new Array(L).fill(0.95);
  for (let l = 0; l < L; l++) {
    const cx = (colX[l]+NODE_W+colX[l+1])/2;
    const box = document.createElement('div'); box.className = 'slider-box';
    box.style.cssText = `left:${cx-SL_W/2}px;top:6px;width:${SL_W}px;`;
    box.innerHTML = `<div class="layer-title">Layer ${l}</div>
      <div class="slider-row"><span class="lbl">H</span>
        <input type="range" id="sl-head-${l}" min="0" max="${H-1}" value="0">
        <span class="val" id="val-head-${l}">0</span></div>
      <div class="slider-row"><span class="lbl">T</span>
        <input type="range" id="sl-thresh-${l}" min="0" max="1000" value="950">
        <span class="val" id="val-thresh-${l}" style="min-width:52px;font-size:9px;"></span></div>`;
    cDiv.appendChild(box);
  }

  document.getElementById('sl-batch').addEventListener('input', debounce(function() {
    curBatch = parseInt(this.value);
    document.getElementById('val-batch').textContent = curBatch;
    updateRedFills(); requestAllThresh(); redrawAllSeg();
  }, 30));

  for (let l = 0; l < L; l++) {
    ((ly) => {
      document.getElementById('sl-head-'+ly).addEventListener('input', debounce(function() {
        curHeads[ly] = parseInt(this.value);
        document.getElementById('val-head-'+ly).textContent = curHeads[ly];
        requestThresh(ly); redrawSegForLayer(ly);
      }, 30));
      document.getElementById('sl-thresh-'+ly).addEventListener('input', debounce(function() {
        curThreshFracs[ly] = parseInt(this.value) / 1000;
        requestThresh(ly);
      }, 30));
    })(l);
  }
  wireSearch();
}

// ================================================================
//  THRESHOLD
// ================================================================
function computeThreshMain(layer) {
  const matrix = getAttentionSlice(layer, curBatch, curHeads[layer]);
  const N = S.N; let mn = Infinity, mx = -Infinity;
  for (let i = 0; i < N*N; i++) { const v = Math.abs(matrix[i]); if(v<mn)mn=v; if(v>mx)mx=v; }
  const thresh = mn + curThreshFracs[layer] * (mx - mn);
  const entries = [];
  for (let r = 0; r < N; r++) for (let c = 0; c < N; c++) {
    const v = Math.abs(matrix[r*N+c]); if(v>=thresh)entries.push({r,c,v});
  }
  entries.sort((a,b) => b.v-a.v);
  const limit = Math.min(entries.length, MAX_TL), range = mx-thresh;
  const result = new Float32Array(limit*3);
  for (let i = 0; i < limit; i++) {
    let alpha = 0.08; if(range>0) alpha = 0.05+((entries[i].v-thresh)/range)*0.45;
    result[i*3]=entries[i].r; result[i*3+1]=entries[i].c; result[i*3+2]=alpha;
  }
  threshCache[layer] = {result, count:limit};
  const v = document.getElementById('val-thresh-'+layer);
  if(v) v.textContent = thresh.toExponential(2);
  drawCanvas();
}

function requestThresh(l) {
  if (useWorkers && workers[l]) {
    const sl = getAttentionSlice(l, curBatch, curHeads[l]);
    workers[l].postMessage({matrix:sl, N:S.N, threshFrac:curThreshFracs[l], maxLines:MAX_TL, layer:l}, [sl.buffer]);
  } else computeThreshMain(l);
}
function requestAllThresh() { for (let l=0;l<S.L;l++) requestThresh(l); }

function onWorkerMsg(e) {
  const {result, layer, thresh, count} = e.data;
  threshCache[layer] = {result: new Float32Array(result), count};
  const v = document.getElementById('val-thresh-'+layer);
  if(v) v.textContent = thresh.toExponential(2);
  drawCanvas();
}

function drawCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let l = 0; l < S.L; l++) {
    const tc = threshCache[l]; if(!tc) continue;
    const {result, count} = tc;
    const x1 = S.colX[l]+NODE_W, x2 = S.colX[l+1];
    ctx.strokeStyle = '#999'; ctx.lineWidth = 0.8;
    for (let i = 0; i < count; i++) {
      ctx.globalAlpha = result[i*3+2];
      ctx.beginPath();
      ctx.moveTo(x1, S.yPos[result[i*3]]+NODE_H/2);
      ctx.lineTo(x2, S.yPos[result[i*3+1]]+NODE_H/2);
      ctx.stroke();
    }
  }
  ctx.globalAlpha = 1;
}

// ================================================================
//  RED FILLS
// ================================================================
function updateRedFills() {
  const bv = getBoundsSlice(curBatch);
  let mx = -Infinity;
  for (let i=0;i<S.N;i++){const a=Math.abs(bv[i]);if(a>mx)mx=a;}
  if(mx<=0)mx=1;
  for (let i=0;i<S.N;i++) redRects[i].setAttribute('width',(Math.abs(bv[i])/mx)*NAME_W);
}

// ================================================================
//  HOVER / PIN
// ================================================================
function showRowBand(i){if(i===activeRowIdx)return;activeRowIdx=i;rowBand.setAttribute('y',S.yPos[i]);rowBand.setAttribute('visibility','visible');}
function hideRowBand(){if(activeRowIdx<0)return;activeRowIdx=-1;rowBand.setAttribute('visibility','hidden');}
function pinRow(i){unpinRow();pinnedIdx=i;pinnedRect=mr(S.bandX,S.yPos[i],S.bandW,NODE_H,'pinband');svgG.pinBand.appendChild(pinnedRect);document.getElementById('search-input').value=S.ids[i];document.getElementById('search-clear').style.display='inline';}
function unpinRow(){if(pinnedRect){pinnedRect.remove();pinnedRect=null;}pinnedIdx=-1;}

// ================================================================
//  TOOLTIP
// ================================================================
function showTT(x,y,l1,l2){
  ttText1.setAttribute('x',x);ttText1.setAttribute('y',y);ttText1.setAttribute('text-anchor','start');
  ttText1.textContent=l1;ttText1.setAttribute('visibility','visible');
  if(l2){ttText2.setAttribute('x',x);ttText2.setAttribute('y',y+13);ttText2.setAttribute('text-anchor','start');ttText2.textContent=l2;ttText2.setAttribute('visibility','visible');}
  else ttText2.setAttribute('visibility','hidden');
  const b1=ttText1.getBBox();let bx=b1.x,by=b1.y,bw=b1.width,bh=b1.height;
  if(l2){const b2=ttText2.getBBox();bx=Math.min(bx,b2.x);by=Math.min(by,b2.y);bw=Math.max(b1.x+b1.width,b2.x+b2.width)-bx;bh=(b2.y+b2.height)-by;}
  ttRect.setAttribute('x',bx-5);ttRect.setAttribute('y',by-3);ttRect.setAttribute('width',bw+10);ttRect.setAttribute('height',bh+6);ttRect.setAttribute('visibility','visible');
}
function hideTT(){ttText1.setAttribute('visibility','hidden');ttText2.setAttribute('visibility','hidden');ttRect.setAttribute('visibility','hidden');}

// ================================================================
//  CHAIN
// ================================================================
function clearChain(){hlRects.forEach(r=>r.remove());segments.forEach(s=>s.forEach(a=>a.remove()));hlRects=[];segments=[];chain=[];}
function makeHL(col,idx){const p=3,r=mr(S.colX[col]-p,S.yPos[idx]-p,NODE_W+p*2,NODE_H+p*2,'hl');svgEl.appendChild(r);return r;}

function makeSeg(kc,ki,qi){
  const m=getAttentionSlice(kc,curBatch,curHeads[kc]),val=m[ki*S.N+qi];
  let rn=Infinity,rx=-Infinity;
  for(let c=0;c<S.N;c++){const v=Math.abs(m[ki*S.N+c]);if(v<rn)rn=v;if(v>rx)rx=v;}
  let nm=0.5;if(rx>rn)nm=(Math.abs(val)-rn)/(rx-rn);
  const lw=0.3+nm*7.7,al=0.2+nm*0.45,arts=[];
  const line=document.createElementNS(svgNS,'line');
  line.setAttribute('x1',S.colX[kc]+NODE_W);line.setAttribute('y1',yc(ki));
  line.setAttribute('x2',S.colX[kc+1]);line.setAttribute('y2',yc(qi));
  line.setAttribute('stroke-width',lw);line.setAttribute('stroke-opacity',al);
  line.classList.add('conn');svgG.conn.appendChild(line);arts.push(line);
  const midx=(S.colX[kc]+NODE_W+S.colX[kc+1])/2,midy=(yc(ki)+yc(qi))/2;
  const lbl=document.createElementNS(svgNS,'text');
  lbl.setAttribute('x',midx);lbl.setAttribute('y',midy-4);lbl.setAttribute('text-anchor','middle');
  lbl.classList.add('vl');lbl.textContent=val.toExponential(3);svgEl.appendChild(lbl);arts.push(lbl);
  return arts;
}

function redrawAllSeg(){for(let i=0;i<segments.length;i++){segments[i].forEach(a=>a.remove());segments[i]=makeSeg(chain[i].col,chain[i].idx,chain[i+1].idx);}}
function redrawSegForLayer(l){for(let i=0;i<segments.length;i++)if(chain[i].col===l){segments[i].forEach(a=>a.remove());segments[i]=makeSeg(chain[i].col,chain[i].idx,chain[i+1].idx);}}
function extend(col,idx){const p=chain[chain.length-1];chain.push({col,idx});hlRects.push(makeHL(col,idx));segments.push(makeSeg(p.col,p.idx,idx));}
function truncFrom(pos){while(hlRects.length>pos)hlRects.pop().remove();const sc=Math.max(0,pos-1);while(segments.length>sc)segments.pop().forEach(a=>a.remove());chain.length=pos;}
function replaceAt(pos,col,idx){
  hlRects[pos].remove();hlRects[pos]=makeHL(col,idx);
  if(pos>0){segments[pos-1].forEach(a=>a.remove());segments[pos-1]=makeSeg(chain[pos-1].col,chain[pos-1].idx,idx);}
  if(pos<chain.length-1){segments[pos].forEach(a=>a.remove());segments[pos]=makeSeg(col,idx,chain[pos+1].idx);}
  chain[pos]={col,idx};
}

// ================================================================
//  SVG EVENTS
// ================================================================
function onSvgClick(e){
  const t=e.target;
  if(t.dataset&&t.dataset.nbar!==undefined){const i=parseInt(t.dataset.nbar);
    if(pinnedIdx===i){unpinRow();document.getElementById('search-input').value='';document.getElementById('search-clear').style.display='none';}else pinRow(i);return;}
  if(!t.dataset||t.dataset.col===undefined)return;
  const col=parseInt(t.dataset.col),idx=parseInt(t.dataset.idx);
  if(!chain.length){chain.push({col,idx});hlRects.push(makeHL(col,idx));return;}
  const pos=col-chain[0].col;
  if(pos===chain.length&&chain[chain.length-1].col<S.L){extend(col,idx);return;}
  if(pos>=0&&pos<chain.length){if(chain[pos].idx===idx)truncFrom(pos);else replaceAt(pos,col,idx);return;}
  clearChain();chain.push({col,idx});hlRects.push(makeHL(col,idx));
}

function onSvgMove(e){
  const t=e.target;
  if(t.dataset&&t.dataset.nbar!==undefined){const i=parseInt(t.dataset.nbar);showRowBand(i);
    const bv=getBoundsSlice(curBatch);showTT(NAME_X+NAME_W+8,S.yPos[i]+NODE_H/2,S.fullNames[i],'Bound: '+bv[i].toExponential(3));return;}
  if(t.dataset&&t.dataset.col!==undefined){const i=parseInt(t.dataset.idx);showRowBand(i);
    showTT(parseFloat(t.getAttribute('x'))+NODE_W+8,parseFloat(t.getAttribute('y'))+NODE_H/2+4,S.fullNames[i],null);return;}
  hideRowBand();hideTT();
}

// ================================================================
//  SEARCH
// ================================================================
function wireSearch(){
  const inp=document.getElementById('search-input'),dd=document.getElementById('dropdown'),clr=document.getElementById('search-clear');
  const idL=S.ids.map(s=>s.toLowerCase()),nmL=S.fullNames.map(s=>s.toLowerCase());
  function match(q){if(!q)return[];q=q.toLowerCase();
    const sc=[];for(let i=0;i<S.N;i++){let s=-1;if(idL[i].startsWith(q))s=3;else if(idL[i].includes(q))s=2;else if(nmL[i].includes(q))s=1;if(s>0)sc.push({idx:i,s});}
    sc.sort((a,b)=>b.s-a.s||a.idx-b.idx);return sc.slice(0,12);}
  function renderDD(ms){dd.innerHTML='';if(!ms.length){dd.style.display='none';return;}dd.style.display='block';
    for(const m of ms){const d=document.createElement('div');d.className='dd-item';
      d.innerHTML=`<b>${S.ids[m.idx]}</b><span class="fullname">${S.fullNames[m.idx]}</span>`;
      d.dataset.idx=m.idx;d.addEventListener('mousedown',ev=>{ev.preventDefault();sel(parseInt(d.dataset.idx));});dd.appendChild(d);}}
  function sel(i){dd.style.display='none';pinRow(i);scrollEl.scrollTop=Math.max(0,S.yPos[i]-scrollEl.clientHeight/2+NODE_H/2);}
  function clrS(){inp.value='';dd.style.display='none';clr.style.display='none';unpinRow();}
  inp.addEventListener('input',()=>{const q=inp.value.trim();clr.style.display=q?'inline':'none';if(!q)unpinRow();renderDD(match(q));});
  inp.addEventListener('focus',()=>{const q=inp.value.trim();if(q)renderDD(match(q));});
  inp.addEventListener('blur',()=>setTimeout(()=>{dd.style.display='none';},150));
  inp.addEventListener('keydown',ev=>{
    const its=dd.querySelectorAll('.dd-item');if(!its.length)return;
    let ai=-1;its.forEach((it,i)=>{if(it.classList.contains('kb-active'))ai=i;});
    if(ev.key==='ArrowDown'){ev.preventDefault();if(ai>=0)its[ai].classList.remove('kb-active');ai=(ai+1)%its.length;its[ai].classList.add('kb-active');}
    else if(ev.key==='ArrowUp'){ev.preventDefault();if(ai>=0)its[ai].classList.remove('kb-active');ai=ai<=0?its.length-1:ai-1;its[ai].classList.add('kb-active');}
    else if(ev.key==='Enter'){ev.preventDefault();if(ai>=0)sel(parseInt(its[ai].dataset.idx));else if(its.length)sel(parseInt(its[0].dataset.idx));}
    else if(ev.key==='Escape'){dd.style.display='none';inp.blur();}
  });
  clr.addEventListener('click',clrS);
}
</script>
</body>
</html>
